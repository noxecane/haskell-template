{-# LANGUAGE TemplateHaskell #-}
module Opaleye.X.TH
  ( HasDefault, NonNullable, NullDefault, Nullable
  , T, TypeNamer
  , mkTable
  , mkTypes
  ) where

import Control.Monad              (foldM, replicateM)
import Data.List.Split            (splitOn)
import X.Prelude                  (capitalise, dashify, uncapitalise)

--import Data.Profunctor.Product.TH (makeAdaptorAndInstance')
import Language.Haskell.TH
import Language.Haskell.TH.Syntax (VarBangType)
import Opaleye                    (Field, FieldNullable, Table)

-- | Descriptor for a "not null" column
data NonNullable r w

-- | Descriptor for a column that can be null
data Nullable r w

-- | Descriptor for a column with default values
data HasDefault r w

-- | Descriptor for a column that can be null with default values
data NullDefault r w

-- Descriptors as internal type
data OType = NN -- NonNullable
           | N  -- Nullable
           | D  -- HasDefault
           | ND -- NullDefault

-- internal dictionary for computation
data Model = Model
  { name :: Name
  , nameStr :: String
  , constructor :: Name
  , fields :: [(Name, Bang, Type)]
  , derivations :: [DerivClause]
  } deriving Show

-- | Interpretation modes
data T = PostgresW | PostgresR | HaskW | HaskR
-- | Function to translate the model name for each interpretation mode
type TypeNamer = T -> String -> String

-- | Declare opaleye types using a single record declaration.
-- For example:
-- @
-- $(declareRecords
--   [d| data Route = Route
--       { id :: HasDefault Int PGInt4
--       , createdAt :: HasDefault UTCTime PGTimestamptz
--       , duration :: Auth.Repo.Nullable String PGText
--       , terminal :: NonNullable Int PGInt4
--       , destination :: NonNullable Text PGText
--       }
--   |])
-- @
-- This translates to:
-- @
-- data Route a_a8Jc a_a8Jd a_a8Je a_a8Jf a_a8Jg
--   = Route {routeId :: a_a8Jc,
--            routeCreatedAt :: a_a8Jd,
--            routeDuration :: a_a8Je,
--            routeTerminal :: a_a8Jf,
--            routeDestination :: a_a8Jg}
-- type RouteR = Route Int UTCTime (Maybe String) Int Text
-- type RouteW =
--     Route (Maybe Int) (Maybe UTCTime) (Maybe String) Int Text
-- type RoutePR =
--     Route (Field PGInt4) (Field PGTimestamptz) (FieldNullable PGText) (Field PGInt4) (Field PGText)
-- type RoutePW =
--     Route (Maybe (Field PGInt4)) (Maybe (Field PGTimestamptz)) (FieldNullable PGText) (Field PGInt4) (Field PGText)
-- @
mkTypes :: Q [Dec] -> Q [Dec]
mkTypes baseTypes = concat <$> (mapM mkType =<< baseTypes)


-- | Generates a table definition for a polymorphic type generated by @mkType@ and
-- an adaptor generated by makeAdaptorAndInstance
-- For example:
-- @$(mkTable "pRoute" Route'')@
-- translates to
-- @
-- routeTable :: Table RoutePW RoutePR
-- routeTable = table "route" (pRoute Route
--   { routeId = tableField "id"
--   , routeCreatedAt = tableField "created_at"
--   , routeDuration = tableField "duration"
--   , routeTerminal = tableField "terminal"
--   , routeDestination = tableField "destination"
--   })
-- @
-- Notice that it uses @dashify@ on the field names.
mkTable :: String -> Name -> Q [Dec]
mkTable p t = do
  tInfo <- reify t
  let (tn, c, fds) = getCons tInfo
  tSig <- mkTableSig tn
  tExp <- mkTableBody p tn c fds
  return $ tSig : [ValD (VarP $ haskellTableName tn) (NormalB tExp) []]
  where
    getCons (TyConI (DataD _ n _ _ [RecC c fds] _)) = (nameBase n, c, map getFieldName fds)
    getCons _                                       = error "Expected a type"
    getFieldName (n, _, _) = n


mkType :: Dec -> Q [Dec]
mkType decl = do
  let model      = decToModel decl
      synCreator = mkTypeSyn defaultTypeNamer model
  let declarations =
        [ mkPolyRecord model
        , synCreator HaskR
        , synCreator HaskW
        , synCreator PostgresR
        , synCreator PostgresW
        ]
  sequence declarations

mkTableSig :: String -> Q Dec
mkTableSig tn = sigD (haskellTableName tn) [t|Table $(tyName PostgresW) $(tyName PostgresR)|]
  where tyName = conT . mkName . flip defaultTypeNamer tn

haskellTableName :: String -> Name
haskellTableName = mkName . (++ "Table") . uncapitalise

mkTableBody :: String -> String -> Name -> [Name] -> Q Exp
mkTableBody pf tn cn flds =
  [e|table $(pgName tn) ($(pFunctor pf) $(rDef))|]
  where
    rDef = recConE cn (map fExp flds)
    fExp x = fieldExp x [e|tableField $(pgField x)|]
    pgName = litE . StringL . dashify
    pFunctor = varE . mkName
    pgField = pgName . unPrefix tn . nameBase

mkPolyRecord :: Model -> Q Dec
mkPolyRecord (Model n ns c fds dvs) = do
  names <- replicateM (length fds) (newName "a")
  let ctvs = map PlainTV names
      tvs  = zipWith poly names fds
  return $ DataD [] n ctvs Nothing [RecC c tvs] dvs
  where
    poly v (n1, b, _)   = (haskellField (uncapitalise ns) n1, b, VarT v)

mkTypeSyn :: TypeNamer -> Model -> T -> Q Dec
mkTypeSyn namer (Model _ ns c fds _) t = do
  let typeName = mkName $ namer t ns
      cns      = ConT c
  typ <- mkTypeSynType cns t fds
  return $ TySynD typeName [] typ

mkTypeSynType :: Type -> T -> [VarBangType] -> Q Type
mkTypeSynType c t fds = foldM appT' c =<< mapM interpreteField fds
  where
    interpreteField (_, _, AppT (AppT desc rType) wType) =
      interpreteDescriptor t (getDescriptor desc) rType wType
    interpreteField _                                    =
      error "Expected descriptor(Nullable, NonNullable...)"
    appT' m = return . AppT m

decToModel :: Dec -> Model
decToModel (DataD _ n _ _ [RecC c fds] dvs) = Model (trueName n) (stripRandomizer n) (trueName c) fds dvs
  where
    trueName = mkName . stripRandomizer
decToModel _                                = error "Expected data declaration"

getDescriptor :: Type -> OType
getDescriptor (ConT m)
  | base == "NonNullable" = NN
  | base == "Nullable"    = N
  | base == "HasDefault"  = D
  | base == "NullDefault" = ND
  | otherwise             = error "Uninterpretable Descriptor"
  where base = nameBase m
getDescriptor _           = error "Uninterpretable Descriptor"

interpreteDescriptor :: T -> OType -> Type -> Type -> Q Type
interpreteDescriptor HaskR N hType _      = [t|Maybe $(return hType)|]
interpreteDescriptor HaskR ND hType _     = [t|Maybe $(return hType)|]
interpreteDescriptor HaskR _ hType _      = return hType
interpreteDescriptor HaskW NN hType _     = return hType
interpreteDescriptor HaskW _ hType _      = [t|Maybe $(return hType)|]
interpreteDescriptor PostgresR N _ pType  = [t|FieldNullable $(return pType)|]
interpreteDescriptor PostgresR ND _ pType = [t|FieldNullable $(return pType)|]
interpreteDescriptor PostgresR _ _ pType  = [t|Field $(return pType)|]
interpreteDescriptor PostgresW NN _ pType = [t|Field $(return pType)|]
interpreteDescriptor PostgresW N _ pType  = [t|FieldNullable $(return pType)|]
interpreteDescriptor PostgresW D _ pType  = [t|Maybe (Field $(return pType))|]
interpreteDescriptor PostgresW ND _ pType = [t|Maybe (FieldNullable $(return pType))|]

defaultTypeNamer :: TypeNamer
defaultTypeNamer PostgresW = (++ "PW")
defaultTypeNamer PostgresR = (++ "PR")
defaultTypeNamer HaskW     = (++ "W")
defaultTypeNamer HaskR     = (++ "R")

haskellField :: String -> Name -> Name
haskellField p = mkName . (p ++) . capitalise . stripRandomizer

stripRandomizer :: Name -> String
stripRandomizer = head . splitOn "_" . nameBase

unPrefix :: String -> String -> String
unPrefix p = drop (length p)
